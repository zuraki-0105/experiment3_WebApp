# 発表会用想定質問＆回答集（ポスター発表版）

このドキュメントは、ポスター発表会で予想される質問とその回答をまとめたものです。

---

## 📌 基本的な質問

### Q: このアプリは何のために作ったのですか？
**A:** 福井市内の飲食店を地図上で視覚的に確認でき、さらに公共交通機関（駅やバス停）からのアクセスを簡単に調べられるようにするためです。
例えば、初めて福井を訪れた人や、車を持っていない学生などが「この店は駅から歩いて行けるかな？」と調べる際に便利です。

### Q: なぜ「最寄りの駅・バス停」を表示する機能をつけたのですか？
**A:** 福井市は地方都市で、車がないと移動が不便な場所も多いです。
そのため、公共交通機関を使う人にとっては「駅やバス停からどれくらい離れているか」という情報が重要になります。
このアプリでは、どの店が徒歩圏内か一目で分かるようになっています。

---

## 📊 データについて

### Q: データはどこから取得したのですか？
**A:** 福井市が公開しているオープンデータを使用しています。
具体的には、飲食店の営業許可データ、駅の位置情報、バス停の位置情報などを組み合わせています。
これらのデータはCSV形式で提供されており、それを整形してデータベースに格納しました。

### Q: データは最新のものですか？更新はできますか？
**A:** データはオープンデータをダウンロードした時点のものです。
更新する場合は、最新のCSVファイルをダウンロードして、データベースを再構築するスクリプトを実行すれば反映できます。

### Q: 他の地域でも使えますか？
**A:** データさえあれば、他の地域でも同じ仕組みで動きます。
オープンデータとして飲食店情報や交通機関の位置情報が公開されている自治体であれば、同様のアプリを作成できます。

---

## 💻 使用している技術

### Q: どんな技術を使っていますか？
**A:**
- **地図表示**: Leaflet（OpenStreetMapベース）
- **サーバー**: Python（FastAPI）
- **データベース**: SQLite
- **フロントエンド**: JavaScript

オープンソースの技術を中心に構築しているので、無料で利用でき、学習にも適しています。

### Q: データ量が多くても動きますか？
**A:** 現在は福井市内の数百件程度のデータなので快適に動作します。
ただし、データが数万件規模になると表示が遅くなる可能性があるため、その場合は「表示範囲内のデータだけを読み込む」などの最適化が必要になります。

---

## 🧮 距離計算のアルゴリズム

### Q: 最寄りの駅・バス停の距離計算はどのように行っていますか？
**A:** 地図ライブラリ「Leaflet」の距離計算機能（`distanceTo`メソッド）を使用しています。
これは、地球を球面とみなして2点間の最短距離を計算する仕組みです。
具体的には**Haversine公式（半正矢公式）**という球面三角法の計算式を用いており、緯度・経度から正確な距離をメートル単位で求めることができます。

### Q: Haversine公式とは何ですか？
**A:** Haversine公式は、球面上の2点間の最短距離を緯度・経度から計算するための数式です。
地球を完全な球体と仮定し、以下のステップで距離を求めます：

1. 2点の緯度・経度の差を計算
2. 特殊な三角関数（Haversine関数）を使って角度を求める
3. その角度に地球の半径（約6,371km）を掛けて距離を算出

この方式により、地球の曲面に沿った実際に近い距離が得られます。
ただし、実際の道のりとは異なるため、あくまで「直線的にどれくらい離れているか」の目安として使用しています。

### Q: すべての駅・バス停との距離を計算しているのですか？もっと効率的な方法はありませんか？
**A:** はい、現在は「全探索」という方法で最も近い駅・バス停を探しています。
つまり、1つの飲食店に対して、すべての駅・バス停との距離を計算し、その中から最小値を見つけています。

より効率的な方法としては、以下のようなアルゴリズムが考えられます：
- **空間インデックス**：事前にデータを空間的に整理しておき、近い地点だけを効率的に検索
- **グリッド分割**：地図を格子状に分割し、同じ格子または隣接格子内のみを検索

ただし、現在のデータ量（駅は数十件、バス停は数百件程度）であれば、全探索でも十分高速に動作するため、シンプルさを優先してこの方式を採用しています。

---

## 🏗️ システム構成

### Q: サーバーとブラウザの役割分担はどうなっていますか？
**A:** このアプリは、サーバー（バックエンド）とブラウザ（フロントエンド）で役割を分けています。

**サーバー側（Python）の役割：**
- データベースからデータを取得
- データをJSON形式で返す
- データの整形やチェック

**ブラウザ側（JavaScript）の役割：**
- 地図の表示とユーザー操作
- 地図上へのマーカー配置
- 最寄り駅・バス停の距離計算
- フィルタリング機能（チェックボックスによる表示切替）

この設計により、サーバーは単純なデータ提供に専念し、計算処理はブラウザ側で行うことで、サーバーの負担を軽くしています。

### Q: データベースの構造はどうなっていますか？
**A:** SQLiteデータベースには3つの主要なテーブルがあります：

1. **飲食店テーブル**：店名、緯度、経度、住所、業態など
2. **駅テーブル**：駅名、路線、鉄道会社、緯度、経度など
3. **バス停テーブル**：停留所名、停留所番号、緯度、経度など

これらのテーブルは独立しており、データベース内での結合は行っていません。
最寄り駅・バス停の検索は、ブラウザ側でそれぞれのデータを取得した後に、JavaScript側で距離計算して行っています。

### Q: なぜ最寄り駅の検索をサーバー側ではなくブラウザ側で行っているのですか？
**A:** 以下の理由から、ブラウザ側で処理する設計を選択しました：

1. **速さ**：ユーザーが地図を操作するたびにサーバーと通信すると遅延が発生します
2. **サーバー負荷の軽減**：計算をブラウザに分散することで、サーバーの負担を減らせます
3. **オフライン対応の可能性**：一度データを取得すれば、追加の通信なしで計算できます
4. **シンプルな設計**：サーバーは単純なデータ提供のみで良く、実装が簡単になります

ただし、データ量が非常に大きくなった場合は、サーバー側で最寄り検索を行う方が効率的になる可能性があります。

---

## ⚡ 非同期処理とパフォーマンス

### Q: 地図上にマーカーを表示するとき、どのように処理していますか？
**A:** JavaScriptの非同期処理機能（`async/await`）を使用して、複数のデータ取得を同時進行で行っています。

具体的には、アプリ起動時に以下の順序で処理されます：
1. 駅データの取得
2. バス停データの取得
3. 飲食店データの取得

駅とバス停のデータを**先に取得**しておくことで、飲食店マーカーを表示する際に、すでにメモリ上にある駅・バス停データを使って距離計算ができます。
この設計により、各マーカーをクリックしたときに、即座に最寄り駅・バス停情報を表示できます。

### Q: フィルタリング機能はどう実装していますか？
**A:** ブラウザ側で、各マーカーに「カテゴリ」という情報を持たせています。
業態分類は以下のロジックで行っています：

- 元データの「業態」文字列に「コンビニ」「スーパー」「喫茶」「カフェ」などのキーワードが含まれるかをチェック
- 該当するカテゴリに分類し、該当しなければ「レストラン」として扱う

ユーザーがチェックボックスを切り替えると、該当するマーカーを地図に表示したり非表示にしたりします（`addTo`/`removeLayer`という処理）。
サーバーへの再通信は不要なため、高速に動作します。

---

## 🚉 時刻表表示機能

### Q: 駅マーカーをクリックしたときに時刻表が表示される仕組みを教えてください
**A:** 駅マーカーをクリックすると、以下の流れで時刻表が表示されます：

1. **サーバーへのリクエスト**：クリックイベントで非同期処理（`async`関数）が動き、時刻表データをサーバーに要求
2. **並列取得**：「くだり」と「のぼり」の時刻表を**同時に**取得（`Promise.all`という仕組みで待ち時間を短縮）
3. **データ整形**：取得したデータを、見やすいHTML形式に変換
4. **ポップアップ表示**：マーカー上に吹き出しウィンドウ（`bindPopup`）として表示

この方式により、ユーザーがクリックしてから1秒以内に時刻表が表示されます。

### Q: 飲食店マーカーをクリックしたときに、最寄り駅の時刻表が下部に表示される仕組みは？
**A:** 飲食店マーカーには、事前に計算した「最寄り駅」の情報が保存されています。
マーカーをクリックすると、以下の処理が行われます：

1. **最寄り駅の特定**：すでに計算済みの最寄り駅名を取得
2. **サイドパネルへの表示**：時刻表表示用の関数（`showStationTimetable`）を呼び出し、画面下部の専用エリアに時刻表を表示
3. **サーバーへのリクエスト**：駅マーカーのクリック時と同じく、時刻表データを取得
4. **HTML更新**：画面の一部分を書き換えて、時刻表を動的に表示

駅マーカーは「ポップアップ」、飲食店マーカーは「サイドパネル」と、表示方法が異なる点が特徴です。

### Q: 時刻表データはどのように取得していますか？
**A:** ブラウザ（JavaScript）と、中継役のサーバー（Python）が連携してデータをやり取りしています。

1. **情報をリクエストする（APIリクエスト）**：  
   ブラウザがサーバーに対して「〇〇駅の、くだり方向の情報をください」とURLを使ってお願いします。
2. **ファイルから情報を探す（バックエンド処理）**：  
   サーバー側では、あらかじめ用意されたデータファイル（CSV形式のファイル）の中から、該当する駅の時刻をパズルのように組み合わせて探し出します。
3. **情報のリストを送り返す（JSON形式のレスポンス）**：  
   見つかった列車の情報を「時刻：〇時〇分、種類：普通」といった**情報のセット（JSON形式）**にしてブラウザに送り返します。
4. **きれいに整えて表示する**：  
   最後にブラウザが、受け取った情報を「10:00 普通：〇〇行き」のように人間が読みやすい文字の形に整えて画面に表示します。

### Q: なぜ「くだり」と「のぼり」を同時に取得しているのですか？
**A:** `Promise.all`という仕組みを使うことで、「くだり」と「のぼり」の時刻表を**並列に取得**できます。

**並列処理の場合**：
- くだりとのぼりを同時にリクエスト → 合計約1秒で完了

**順番に処理する場合**：
- くだりを取得（1秒） → のぼりを取得（1秒） → 合計約2秒

つまり、並列処理により**待ち時間を半分に短縮**できます。
これはユーザーの待ち時間を減らし、快適な操作感につながります。

---

## 🎓 教授・専門家レベルの深掘り質問

### Q: 飲食店データと交通機関データの「名寄せ（正規化）」はどう処理していますか？
**A:** 異なるデータソース（CSV）を組み合わせる際、駅名の表記揺れを解決するために「表記の整え（正規化：Normalization）」を行っています。

具体的には、プログラム（`main.js`）内で以下の処理を行っています：
1. **不要な情報の削除**：駅名に含まれる「（）」内の補足情報や空白を削除（`replace`処理）
2. **例外処理**：「福井駅」以外のデータから語尾の「駅」を削除して統一

これにより、データごとに「駅」が付いていたりいなかったりしても、正しく時刻表データを紐付けられるようにしています。

### Q: 地球を「球」として計算していますが、より精度の高い「楕円体」モデルを使わない理由は？
**A:** 地球は正確には赤道方向に膨らんだ「楕円体（Ellipsoid）」ですが、本アプリではシンプルで計算の速い「球面（Spherical）」モデル（Haversine公式）を採用しています。

福井市内という**狭い範囲（ローカルなスケール）**での検索においては、球面モデルと楕円体モデル（Vincenty法など）の誤差はごくわずか（数センチ〜数メートル程度）です。ユーザーが徒歩やバスで移動する際の目安としては球面モデルの精度で十分実用的であり、計算コストを抑えるメリットの方が大きいと判断しました。

### Q: 現在の「全探索」はデータ量が増えると破綻しませんか？（計算量の問題）
**A:** ご指摘の通り、現在の実装は**計算量（Complexity）**が O(N) です。
データ数が10倍、100倍になるとブラウザの動作が重くなります。

もし全国規模に拡張する場合は、**空間インデックス（Spatial Index）**の導入が必要です。具体的には、データを地名や範囲ごとに木構造で管理する「R木 (R-tree)」や、地図を格子状に区切る「ジオハッシュ」などを用いることで、計算量を O(log N) まで抑え、数万件以上のデータからでも瞬時に最寄り検索が可能になります。

### Q: データベースにSQLiteを選んでいますが、並列アクセス時の安全性はどう確保していますか？
**A:** FastAPI（Python）でSQLiteを扱う際、複数の処理が同時にデータベースを書き換えないよう、接続設定（`check_same_thread=False`）とSQLAlchemyの**セッション管理**を組み合わせています。

本アプリは基本的に「データの読み取り」が中心であるため、SQLiteのファイルロック機構でも十分なパフォーマンスを維持できます。もし将来的に多くのユーザーが同時に「口コミ」を書き込むような仕組み（書き込み量が多い）にする場合は、PostgreSQLなどの並列処理に強いデータベースへの移行を検討します。

### Q: オープンデータのクリーニングで、どのような「例外的なデータ」に遭遇し、どう対処しましたか？
**A:** データベース作成ツール（`prepare_db.py`）の実装時に、主に以下の「汚れたデータ（Dirty Data）」に対処しました：

1. **不正な座標**：緯度・経度が `0.0` や空白になっているデータ → 地図表示に支障が出るため、読み込み時にスキップ（バリデーション）
2. **文字コードの問題**：Shift-JISとUTF-8が混在する可能性があるため、エラーを置換（`errors='replace'`）して処理を止めないように工夫
3. **欠損値**：バス停番号などの数字がない場合に、デフォルト値を設定したり、型変換（`safe_float`, `safe_int`）でエラーを防ぐ処理を追加しました。

このように、単にデータを読み込むだけでなく、プログラムが途中で止まらないような**堅牢性（Robustness）**を意識した実装にしています。

### Q: 緯度経度の「測地系（Coordinate System）」は何を使用していますか？ 日本の旧いデータとの互換性は？
**A:** 本アプリでは、世界標準の**WGS84（世界測地系）**を前提としています。

福井市のオープンデータは基本的に最新の**JGD2011（日本測地系2011）**で提供されており、これはWGS84とほぼ同一視できるため、特別な変換なしで地図上に正しく表示できます。もし、明治時代などの非常に古い地図データ（日本測地系：Tokyo Datum）を扱う場合は、座標が数百メートルずれてしまうため、楕円体パラメータを用いた座標変換（緯度経度のシフト処理）が必要になります。

### Q: Python側でグローバル変数を使ってキャッシュしていますが、スレッドセーフ（Thread-safe）ですか？
**A:** ご指摘の通り、`timetable_service.py` で時刻表データを一括ロードして `_station_map` という変数にキャッシュしています。

現在の実装は、最初にリクエストが来た時に「なければロードする」というシンプルな方式です。厳密なマルチスレッド環境（多数の同時アクセスがある環境）では、複数の処理が同時にデータをロードし始めてしまう「競合状態（Race Condition）」が起こる可能性があります。
実務的な対策としては、サーバー起動時にあらかじめロードを完了させておく（`on_event("startup")` を使う）か、Pythonのロック機構（`threading.Lock`）を用いて、ロード処理を1つだけに制限する排他制御を実装するのが望ましいと考えています。

---

